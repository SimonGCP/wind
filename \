use std::{
    net::{
        TcpStream, 
        TcpListener
    },
    fs,
    io::{
        Write,
        BufReader,
        prelude::*,
        Error,
        ErrorKind,
    },
    vec::Vec,
};

use crate::route::Route;
use crate::response::Response;

pub struct Router {
    root: String,
    routes: Vec<Route>,   
}

impl Router {
    pub fn new(root: &str) -> Router {
        let root = root.to_string();

        Router {
            root: root.to_string(),
            routes: Vec::new(),
        }
    }

    pub fn listen(&self, address: &str) {
        let listener: TcpListener = TcpListener::bind(address).unwrap();

        println!("Starting server at {}", address);
        for client in listener.incoming() {
            match client {
                Ok(stream) => {
                    self.handle_client(stream); 
                }
                Err(e) => panic!("Error connecting: {e}"),
            }
        }
    }

    pub fn route(&mut self, path: &str, result: Box<dyn Fn() -> Result<Response, Error>>) -> Result<(), String> {
        let new_route = Route::new(path, Box::new(result)); 
        self.routes.push(new_route); 

        Ok(())
    }

    pub fn handle_client(&self, mut stream: TcpStream) {
        let buf_reader = BufReader::new(&stream);
        let http_request: Vec<_> = buf_reader
            .lines()
            .map(|result| result.unwrap())
            .take_while(|line| !line.is_empty())
            .collect();

        if http_request.len() < 1 {
            println!("{:?}", http_request);
            return
        }

        println!("client request: {}", http_request[0]);

        let content_type = String::from("text/html");
        let request: Vec<&str> = http_request[0]
            .as_str()
            .split("?")
            .collect();

        for strings in request {
            println!("{}", strings);
        }

        let request = http_request.get(0).unwrap();

        let mut response: Result<Response, std::io::Error> = Err(Error::new(ErrorKind::Other, "Not initialized"));

        if request.starts_with("GET") {
            let request = &request[4..]; // remove GET part of request

            // checks if the HTTP request has extra parameters
            let contains_params = request.contains("?"); 
            let request = request.replace("?", " "); 

            let words: Vec<_> = request.split(" ").collect();
            let request = String::from(*words.get(0).unwrap());

            let params = match contains_params {
                true => Some(String::from(*words.get(1).unwrap())),
                false => None, 
            };

            println!("Path: \"{}\"", request);
            println!("Params: \"{}\"", params.unwrap_or(String::from("None")));

            for route in &self.routes {
                if route.path == request {
                    println!("Route path: \"{}\"", route.path);
                    response = route.get_result();

                    break;
                } 
            }

            // if no route, check for matching files
            if response.is_err() {
                let e = response.unwrap_err();
                match e.kind() {
                    ErrorKind::Other => { 
                        println!("sending: {}{}", self.root, request);
                        response = fs::read(format!("{}{}", self.root, request)).unwrap()
                    },
                    _ => panic!("{:?}", e),
                }
            }
        }
        
        let response = response.unwrap_or(vec![0u8]);
        send_response(content_type, &response, &mut stream).unwrap();
    }
}

// helper functions

fn send_response(content_type: String, content: &Vec<u8>, stream: &mut TcpStream) -> Result<(), std::io::Error> {
    let write_string = format!("HTTP/1.1 200 OK\r\nContent-Type: {}\r\nContent-Length: {}\r\n\r\n",
        content_type,
        content.len()
    );
    let write_string = write_string.as_bytes();

    let res1 = stream.write_all(write_string);
    if res1.is_err() {
        res1
    } else {
        stream.write_all(content)
    }
}
